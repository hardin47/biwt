[{"path":"https://hardin47.github.io/biwt/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Jo Hardin Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Resistant correlations and clustering with the biwt package","text":"vignette walks reader calculating resistant multivariate estimates correlations. methods applied presidential election data 1856 2020 uncover voting patterns. functions biwt package based following published work: Hardin, J., Mitani, ., Hicks, L., VanKoten, B.; Robust Measure Correlation Two Genes Microarray, BMC Bioinformatics, 8:220; 2007.","code":""},{"path":[]},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"functions-for-resistant-estimation","dir":"Articles","previous_headings":"biwt package functions","what":"Functions for resistant estimation","title":"Resistant correlations and clustering with the biwt package","text":"start providing two functions return resistant mean covariance values Tukey’s biweight estimation. Note difference two functions biwt.est() requires 2×n2 \\times n matrix data frame (n number measurements) biwt_est() requires n×2n \\times 2 matrix data frame (n number observations).","code":""},{"path":[]},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"biwt-estx-r-0-2-med-init-covmcdx","dir":"Articles","previous_headings":"biwt package functions > Functions for resistant estimation > biwt.est()","what":"biwt.est(x, r = 0.2, med.init = covMcd(x))","title":"Resistant correlations and clustering with the biwt package","text":"function inputs 2×n2 \\times n matrix, breakdown (percent data can ignored), initial estimate center shape data. outputs measure center shape data using Tukey’s biweight M-estimator.","code":""},{"path":[]},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"biwt_estx-r-med-init","dir":"Articles","previous_headings":"biwt package functions > Functions for resistant estimation > biwt_est()","what":"biwt_est(x, r, med.init)","title":"Resistant correlations and clustering with the biwt package","text":"function inputs arguments biwt.est(), data input transposed. , input matrix n×2.n \\times 2. output biwt.est().","code":""},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"functions-for-resistant-correlation","dir":"Articles","previous_headings":"biwt package functions","what":"Functions for resistant correlation","title":"Resistant correlations and clustering with the biwt package","text":"Based Tukey’s biweight estimation, biwt.cor() biwt_cor() provide resistant estimates correlation. Note difference two functions biwt.cor() requires g×ng \\times n matrix data frame (n number measurements, g number observations (genes)) biwt_cor() requires n×gn \\times g matrix data frame (n number measurements, g number observations (genes)).","code":""},{"path":[]},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"biwt-corx-r-0-2-output-matrix-median-true-full-init-true-absval-true","dir":"Articles","previous_headings":"biwt package functions > Functions for resistant correlation > biwt.cor()","what":"biwt.cor(x, r = 0.2, output = \"matrix\", median = TRUE, full.init = TRUE, absval = TRUE)","title":"Resistant correlations and clustering with the biwt package","text":"function inputs g×ng \\times n matrix, breakdown, intended output, command determine whether initialization done using coordinate-wise median MAD using minimum covariance determinant (MCD), argument determine whether initialization done pair separately, argument determine whether [output distance] distance measured 1 minus absolute value correlation 1 minus correlation. output matrix, vector, distance, depending output argument.","code":""},{"path":[]},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"biwt_corx-r-median-true-full-init-true","dir":"Articles","previous_headings":"biwt package functions > Functions for resistant correlation > biwt_cor()","what":"biwt_cor(x, r, median = TRUE, full.init = TRUE)","title":"Resistant correlations and clustering with the biwt package","text":"function inputs n×gn \\times g matrix, breakdown, argument determine whether initialization done using coordinate-wise median MAD using minimum covariance determinant (MCD), argument determine whether initialization done pair separately. function outputs vector (g,2)\\choose{g,2} biweight correlations.","code":""},{"path":[]},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"biwt_cor_matrixx-r-median-true-full-init-true","dir":"Articles","previous_headings":"biwt package functions > Functions for resistant correlation > biwt_cor_matrix()","what":"biwt_cor_matrix(x, r, median = TRUE, full.init = TRUE)","title":"Resistant correlations and clustering with the biwt package","text":"function inputs n×gn \\times g matrix, breakdown, argument determine whether initialization done using coordinate-wise median MAD using minimum covariance determinant (MCD), argument determine whether initialization done pair separately one time beginning using entire data matrix. function outputs g×gg \\times g matrix biweight correlations.","code":""},{"path":[]},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"biwt_dist_matrixx-r-median-true-full-init-true-absval-true","dir":"Articles","previous_headings":"biwt package functions > Functions for resistant correlation > biwt_dist_matrix()","what":"biwt_dist_matrix(x, r, median = TRUE, full.init = TRUE, absval = TRUE)","title":"Resistant correlations and clustering with the biwt package","text":"function inputs n×gn \\times g matrix, breakdown, argument determine whether initialization done using coordinate-wise median MAD using minimum covariance determinant (MCD), argument determine whether initialization done pair separately, argument determine whether distance measured 1 minus absolute value correlation 1 minus raw correlation. function outputs g×gg \\times g matrix biweight distances (either 1 - correlation 1 - absolute correlation).","code":""},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"correlation","dir":"Articles","previous_headings":"","what":"Correlation","title":"Resistant correlations and clustering with the biwt package","text":"goal functions biwt package produce correlations resistant rogue data. resistant method produces results change slightly small part data replaced new numbers, possibly different fromt original ones. [Hoaglin, Mosteller, Tukey, Understanding Robust Exploratory Data Analysis, pg 2. 1983] example, median resistant measure center even data values replaced extreme values, median remain roughly since middle number. However, 50% data changed, median’s value change. mean resistant measure center. observations replaced extreme values, mean drawn values. Tukey’s biweight gives zero weight observations sufficiently far bulk data, thus discounting calculation center, shape, correlation.","code":""},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"biweight-correlation","dir":"Articles","previous_headings":"Correlation","what":"Biweight Correlation","title":"Resistant correlations and clustering with the biwt package","text":"Biweight correlation resistant correlation method used find accurate correlation multivariate data presence outliers. biweight correlation functions set (default) resistant outlier proportion 20%. Sufficiently far outlying points given zero weight, correlation calculated without observations, yielding correlation resistant extreme values.","code":""},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"pearson-correlation","dir":"Articles","previous_headings":"Correlation","what":"Pearson Correlation","title":"Resistant correlations and clustering with the biwt package","text":"Unlike Tukey’s biweight correlation, Pearson correlation calculated observations, getting equal weight. Therefore, Pearson correlation resistant extreme value can large impact correlation calculation.","code":""},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"comparison-of-biweight-and-pearson-correlation-on-clean-data","dir":"Articles","previous_headings":"Correlation","what":"Comparison of Biweight and Pearson correlation on clean data","title":"Resistant correlations and clustering with the biwt package","text":"data clean, meaning outliers, correlation functions able accurately estimate true population correlation using sample. also known Pearson correlation maximum likelihood estimator true correlation uncontaminated bivariate normal populations (quality brings many nice properties). start clean data (contamination) display single sample, estimated correlation values close true parameter 0.75. Additionally, show example single sample generated bivariate normal distribution correlation parameter 0.75. Biweight Pearson correlations sample 100 observations uncontaminated bivariate normal distribution population correlation 0.75. Plot uncontaminated bivariate normal sample size 100 population true correlation 0.75.","code":"set.seed(4747) # The `contamination` function generates a dataset with `p` percent # contaminated data. # `n`: number of observations # `p`: percent of contaminated observations # `pc`: correlation of the population from which the data are generated # `u1x`: lower bound of uniform dist on x-axis (contaminated data) # `u2x`: upper bound of uniform dist on x-axis (contaminated data) # `u1y`: lower bound of uniform dist on y-axis (contaminated data) # `u2y`: upper bound of uniform dist on y-axis (contaminated data) contamination <- function(n = 100, p = 0.1, pc = 0.75,                            u1x = -3, u2x = -1, u1y = 15, u2y = 25){     temp2 <- rbind(data.frame(MASS::mvrnorm(n*(1-p), mu = c(0,0),                            Sigma = matrix(c(1,pc,pc,1), ncol= 2))),                 cbind(X1 = runif(n*p, u1x, u2x), X2 = runif(n*p, u1y, u2y)))     return(data = temp2) }   # The `correlation_func` function simulates contaminated data # and returns both the biweight and the Pearson correlation # `r`: the breakdown (% of allowed contamination) correlation_func <- function(r = 0.2, n = 100, p = 0.1, pc = 0.75,                               u1x = -3, u2x = -1, u1y = 15, u2y = 25){      samp_data <- contamination(n = n, p = p, pc = pc,                               u1x = u1x, u2x = u2x, u1y = u1y, u2y = u2y)    return(data.frame(bwcorrelation = biwt_cor(samp_data, r)$biwt_corr,                      pcorrelation = cor(samp_data)[1,2]))  }  # First, run the correlation function on clean (uncontaminated) data correlation_func(p = 0) |>    gt::gt(caption = \"Biweight and Pearson correlations from a sample of 100 observations in an uncontaminated bivariate normal distribution with population correlation of 0.75.\") |>    gt::cols_label(bwcorrelation = \"biweight correlation\",               pcorrelation = \"Pearson correlation\") |>    gt::tab_options(table.width = gt::pct(85)) contamination(n = 100, p = 0, pc = 0.75, u1x = -3, u2x = -1, u1y = 15, u2y = 25) |>      ggplot() +   geom_point(aes(x = X1, y = X2)) +    labs(x = \"first coordinant\",        y = \"second coordinant\",        title = \"Uncontaminated dataset\") +    theme_minimal()"},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"comparison-of-biweight-and-pearson-correlation-on-contaminated-data","dir":"Articles","previous_headings":"Correlation","what":"Comparison of Biweight and Pearson correlation on contaminated data","title":"Resistant correlations and clustering with the biwt package","text":"data contaminated, biweight correlation able estimate underlying population correlation accurately Pearson correlation . biweight weights contaminated data calculates correlation remaining uncontaminated values. example , 10% data replaced contamination distributed uniformly xx direction -3 -1 uniformly yy direction 15 25. provide correlation values (biweight Pearson) contaminated data note biweight value much closer population parameter (0.75) Pearson correlation . Additionally, show example single sample generated contaminated (10% observations) bivariate normal distribution correlation parameter 0.75. Biweight Pearson correlations sample 100 observations 10% contaminated bivariate normal distribution population correlation 0.75. Plot 10% contaminated bivariate normal sample size 100 population true correlation 0.75.","code":"# using the default values correlation_func(r = 0.2, n = 100, p = 0.1, pc = 0.75,                  u1x = -3, u2x = -1, u1y = 15, u2y = 25)|>    gt::gt(caption = \"Biweight and Pearson correlations from a sample of 100 observations in a 10% contaminated bivariate normal distribution with population correlation of 0.75.\") |>    gt::cols_label(bwcorrelation = \"biweight correlation\",               pcorrelation = \"Pearson correlation\") |>    gt::tab_options(table.width = gt::pct(85)) # using the default values contamination(n = 100, p = 0.1, pc = 0.75,                u1x = -3, u2x = -1, u1y = 15, u2y = 25) |>    ggplot() +   geom_point(aes(x = X1, y = X2)) +    labs(x = \"first coordinant\",        y = \"second coordinant\",        title = \"Dataset with 10% contamination\") +    theme_minimal()"},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"simulation-study","dir":"Articles","previous_headings":"","what":"Simulation Study","title":"Resistant correlations and clustering with the biwt package","text":"following simulation study, investigate different contamination levels assess resulting biweight Pearson correlations.","code":""},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"example-1-breakdown-contamination-20-compressed-contamination","dir":"Articles","previous_headings":"Simulation Study","what":"Example #1: breakdown > contamination, 20% compressed contamination","title":"Resistant correlations and clustering with the biwt package","text":"breakdown (r = 0.3) greater percentage contamination (p = 0.2), contaminated data weighted biweight correlation computation. result biweight correlation estimates accurate Pearson correlation estimates. One simulated dataset n = 100, 20% compressed contamination, population correlation 0.75. Histogram correlations 500 random samples. 500 datasets n = 100 20% compressed contamination. pink vertical line population correlation, 0.75. Scatterplot describing biweight Pearson correlations calculated 500 contaminated datasets. pink vertical horizontal lines population correlation, 0.75.","code":"data1 <- contamination(n = 100, p = 0.2, pc = 0.75,                        u1x = -3, u2x = -1, u1y = 15, u2y = 25)  data1 |>   ggplot() +   geom_point(aes(x = X1, y = X2)) +    labs(x = \"first coordinant\",        y = \"second coordinant\",        title = \"Dataset with 20% compressed contamination\") +    theme_minimal() correlation1 <- 1:500 |>    map_dfr(~correlation_func(r = 0.3, n = 100, p = 0.2, pc = 0.75,                              u1x = -3, u2x = -1, u1y = 15, u2y = 25))  correlation_long1 <- correlation1 |>   pivot_longer(cols = c (\"bwcorrelation\", \"pcorrelation\"),                 names_to = \"statistic\", values_to = \"value\")  correlation_long1 |>   mutate(statistic = case_when(     statistic == \"bwcorrelation\" ~ \"biweight correlation\",     statistic == \"pcorrelation\" ~ \"Pearson correlation\"   )) |>    ggplot(aes(x = value)) +   geom_histogram(bins = 30) +   geom_vline(xintercept = 0.75, color = \"pink\") +    facet_wrap(~statistic) +    theme_minimal() +   labs(x = \"correlation value\", y = \"\") correlation1 |>   ggplot(aes()) +   geom_point(aes(x = bwcorrelation, y = pcorrelation)) +   geom_vline(xintercept = 0.75, color = \"pink\") +    geom_hline(yintercept = 0.75, color = \"pink\") +    theme_minimal() +   labs(x = \"biweight correlation\",        y = \"Pearson correlation\",        title = \"biweight and Pearson correlation for each \\nof 500 simulated datasets\")"},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"example-2-breakdown-contamination-20-diffuse-contamination","dir":"Articles","previous_headings":"Simulation Study","what":"Example #2: breakdown > contamination, 20% diffuse contamination","title":"Resistant correlations and clustering with the biwt package","text":"changing range outlying contamination comes , can see impact contamination biweight Pearson correlations. Despite contamination quite diffuse, biweight able estimate correlation close true value 0.75. Note expect biweight correlation accurate percentage contamination less breakdown. Pearson correlation better diffuse correlation compressed correlation, Pearson estimates still close true value 0.75. compressed contamination provided Pearson correlation estimates close -0.5, diffuse contamination Pearson correlation estimates centered roughly around zero. One simulated dataset n = 100, 20% diffuse contamination, population correlation 0.75. Histogram correlations 500 random samples. 500 datasets n = 100 20% diffuse contamination. pink vertical line population correlation, 0.75. Scatterplot describing biweight Pearson correlations calculated 500 20% diffuse contaminated datasets. pink vertical horizontal lines population correlation, 0.75.","code":"data2 <- contamination(n = 100, p = 0.2, pc = 0.75,                         u1x = -10, u2x = 10, u1y = -10, u2y = 10)  data2 |>   ggplot() +   geom_point(aes(x = X1, y = X2)) +    labs(x = \"first coordinant\",        y = \"second coordinant\",        title = \"Dataset with 20% diffuse contamination\") +    theme_minimal() correlation2 <- 1:500 |>    map_dfr(~correlation_func(r = 0.3, n = 100, p = 0.2, pc = 0.75,                              u1x = -10, u2x = 10, u1y = -10, u2y = 10))  correlation_long2 <- correlation2 |>   pivot_longer(cols = c(\"bwcorrelation\", \"pcorrelation\"),                 names_to = \"statistic\", values_to = \"val\")  correlation_long2 |>   mutate(statistic = case_when(     statistic == \"bwcorrelation\" ~ \"biweight correlation\",     statistic == \"pcorrelation\" ~ \"Pearson correlation\"   )) |>    ggplot(aes(x = val)) +   geom_histogram(bins = 30) +   geom_vline(xintercept = 0.75, color = \"pink\") +    facet_wrap(~statistic) +    theme_minimal() +   labs(x = \"correlation value\", y = \"\") correlation2 |>   ggplot(aes()) +   geom_point(aes(x = bwcorrelation, y = pcorrelation)) +   geom_vline(xintercept = 0.75, color = \"pink\") +    geom_hline(yintercept = 0.75, color = \"pink\") +    theme_minimal() +   labs(x = \"biweight correlation\",        y = \"Pearson correlation\",        title = \"biweight and Pearson correlation for each \\nof 500 simulated datasets\")"},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"example-3-breakdown-contamination-40-compressed-contamination","dir":"Articles","previous_headings":"Simulation Study","what":"Example #3: breakdown < contamination, 40% compressed contamination","title":"Resistant correlations and clustering with the biwt package","text":"next example retains parameters Example #1 one change. proportion contamination increased 40%. Recall breakdown set 30%, contamination higher breakdown. Given contamination higher breakdown, biweight longer able estimate correlation close true parameter 0.75. biweight set consider (.e., downweight) 30% observations outlying, 40% contamination sets contamination part bulk observations. contamination values, Pearson correlation unable accurately estimate true parameter 0.75. One simulated dataset n = 100, 40% compressed contamination, population correlation 0.75. Histogram correlations 500 random samples. 500 datasets n = 100 40% compressed contamination. pink vertical line population correlation, 0.75. Scatterplot describing biweight Pearson correlations calculated 500 40% compressed contaminated datasets. pink vertical horizontal lines population correlation, 0.75.","code":"data3 <- contamination(n = 100, p = .4, pc = 0.75,                         u1x = -3, u2x = -1, u1y = 15, u2y = 25)  data3 |>   ggplot() +   geom_point(aes(x = X1, y = X2)) +    labs(x = \"first coordinant\",        y = \"second coordinant\",        title = \"Dataset with 40% compressed contamination\") +    theme_minimal() correlation3 <- 1:500 |>    map_dfr(~correlation_func(r = 0.3, n = 100, p = .4, pc = 0.75,                              u1x = -3, u2x = -1, u1y = 15, u2y = 25))  correlation_long3 <- correlation3 |>   pivot_longer(cols = c(\"bwcorrelation\", \"pcorrelation\"),                 names_to = \"statistic\", values_to = \"value\")  correlation_long3 |>   mutate(statistic = case_when(     statistic == \"bwcorrelation\" ~ \"biweight correlation\",     statistic == \"pcorrelation\" ~ \"Pearson correlation\"   )) |>    ggplot(aes(x = value)) +   geom_histogram(bins = 30) +   geom_vline(xintercept = 0.75, color = \"pink\") +    facet_wrap(~statistic) +    theme_minimal() +   labs(x = \"correlation value\", y = \"\") correlation3 |>   ggplot(aes()) +   geom_point(aes(x = bwcorrelation, y = pcorrelation)) +   geom_vline(xintercept = 0.75, color = \"pink\") +    geom_hline(yintercept = 0.75, color = \"pink\") +    theme_minimal() +   labs(x = \"biweight correlation\",        y = \"Pearson correlation\",        title = \"biweight and Pearson correlation for each \\nof 500 simulated datasets\")"},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"example-4-low-population-correlation-parameter-of-0-1-20-compressed-contamination","dir":"Articles","previous_headings":"Simulation Study","what":"Example #4: low population correlation parameter of 0.1, 20% compressed contamination","title":"Resistant correlations and clustering with the biwt package","text":"One last change allows compare biweight Pearson correlations. , parameter settings Example #1 one change. true population correlation set 0.1 (much weaker correlation). see value population correlation strong effect ability biweight estimate correlation well Pearson estmate correlation poorly. results Example #4 quite similar results Example #1. One simulated dataset n = 100, 20% compressed contamination, population correlation 0.1. Histogram correlations 500 random samples. 500 datasets n = 100 20% compressed contamination. pink vertical line population correlation, 0.1. Scatterplot describing biweight Pearson correlations calculated 500 contaminated datasets. pink vertical horizontal lines population correlation, 0.1.","code":"data4 <- contamination(n = 100, p = 0.2, pc = 0.1,                         u1x = -3, u2x = -1, u1y = 15, u2y = 25)  data4 |>   ggplot() +   geom_point(aes(x = X1, y = X2)) +    labs(x = \"first coordinant\",        y = \"second coordinant\",        title = \"Dataset with 20% compressed contamination\") +    theme_minimal() correlation4 <- 1:500 |>    map_dfr(~correlation_func(r = 0.3, n = 100, p = 0.2, pc = 0.1,                              u1x = -3, u2x = -1, u1y = 15, u2y = 25))  correlation_long4 <- correlation4 |>   pivot_longer(cols = c (\"bwcorrelation\", \"pcorrelation\"), names_to = \"statistic\", values_to = \"value\")  correlation_long4 |>   mutate(statistic = case_when(     statistic == \"bwcorrelation\" ~ \"biweight correlation\",     statistic == \"pcorrelation\" ~ \"Pearson correlation\"   )) |>    ggplot(aes(x = value)) +   geom_histogram(bins = 30) +   geom_vline(xintercept = 0.1, color = \"pink\") +    facet_wrap(~statistic) +    theme_minimal() +   labs(x = \"correlation value\", y = \"\") correlation4 |>   ggplot(aes()) +   geom_point(aes(x = bwcorrelation, y = pcorrelation)) +   geom_vline(xintercept = 0.1, color = \"pink\") +    geom_hline(yintercept = 0.1, color = \"pink\") +    theme_minimal() +   labs(x = \"biweight correlation\",        y = \"Pearson correlation\",        title = \"biweight and Pearson correlation for each \\nof 500 simulated datasets\")"},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"presidential-candidate-voting-data","dir":"Articles","previous_headings":"","what":"Presidential Candidate Voting Data","title":"Resistant correlations and clustering with the biwt package","text":"following clustering example models data every US presidential election 1856 2020. row dataset one 50 United States. column represents percentage votes Republican candidate election, 42 elections 1856 2020. Note looking cluster states, .e., rows (using information years = columns). end, main biwt R package functions used biwt.cor(). data 1856-1972 provided cluster R package (available CRAN) dataset name votes.repub. data 1976-2020 found Harvard Dataverse, US President 1976-2020. second dataset CC0 1.0 Universal license, included GitHub repository biwt R package part vignette.","code":"# combining the two datasets and creating  # a single data frame with the relevant information votes_repub <- cluster::votes.repub  newer_president <- read_csv(\"data/1976-2020-president.csv\") |>    mutate(percent = candidatevotes / totalvotes * 100) |>    filter(party_detailed == \"REPUBLICAN\" & !writein) |>    filter(state != \"DISTRICT OF COLUMBIA\") |>    dplyr::select(year, state, percent) |>    pivot_wider(id_cols = state, names_from = year, values_from = percent)  all_votes_repub <- cbind(votes_repub, newer_president) |>    dplyr::select(-state, -X1976)  years <- as.numeric(gsub(\"X\", \"\", colnames(all_votes_repub)))  # For states that did not exist or vote during certain years # (i.e. Alaska and Hawaii), the NA data is ignored. dend_NA <- votes_repub |>    is.na() |>   dist() |>    hclust() |>    as.dendrogram() |>    dendextend::ladderize()  color_gradient <- colorspace::diverge_hcl"},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"dendrograms","dir":"Articles","previous_headings":"Presidential Candidate Voting Data","what":"Dendrograms","title":"Resistant correlations and clustering with the biwt package","text":"Dendrograms visualization hierarchical clustering analysis. hierarchical clustering agglomerates observations (, states) one time based states closest one another. dendrogram displays entire agglomeration algorithm shorter vertical bars indicating states (groups states) closest one another longer vertical bars indicating states (groups states) farther one another. work use complete linkage. result identify states similar voting patterns (measured percent Republican vote) across almost 200 years presidential races. biweight correlation distance measure metric seems cluster states way similar politics across states considered. , biweight correlation distance best model option.","code":""},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"biweight-dendrogram","dir":"Articles","previous_headings":"Presidential Candidate Voting Data > Dendrograms","what":"Biweight dendrogram","title":"Resistant correlations and clustering with the biwt package","text":"biweight correlation distance (two states) calculated one minus biweight correlation two states. can observe two quite distinct groups states: states first arm (left side) primarily states now considered left leaning “blue”; states second arm (right side) primarily states now considered right leaning “red.” biweight distance measure excellent job distinguishing two groups states.","code":"dist.repub <- all_votes_repub |>    biwt.cor(r = 0.2, absval = FALSE, output = \"distance\") |>   as.dist() |>   usedist::dist_setNames(rownames(votes_repub)) |>   hclust(method = \"complete\") |>    as.dendrogram() |>   plot(ylab = \"biweigtht correlation distance\")"},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"euclidean-dendrogram","dir":"Articles","previous_headings":"Presidential Candidate Voting Data > Dendrograms","what":"Euclidean dendrogram","title":"Resistant correlations and clustering with the biwt package","text":"Euclidean distance calculated using Euclidean distance Republican voting shares 1856 2020. clear distinctions dendrogram identify groups states similar. breaking states clusters, 2 groups produce almost states cluster (except MS, SC, FL, AK, TX, LA, AL, GA). smaller two clusters might meaningfully related, seems though linking 42 states might broad. However, break dendrogram additional cluster (3 clusters? 4 clusters? 5 clusters?) obvious task.","code":"dist.repub <- all_votes_repub |>    dist()|>   hclust(method = \"complete\") |>    as.dendrogram() |>   plot(ylab = \"Euclidean distance\")"},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"pearson-dendrogram","dir":"Articles","previous_headings":"Presidential Candidate Voting Data > Dendrograms","what":"Pearson dendrogram","title":"Resistant correlations and clustering with the biwt package","text":"Pearson distance (two states) calculated one minus Pearson correlation two states. , like Euclidean distance dendrogram, obvious cutoff values determine best number clusters. Possibly, 6 7 clusters, groupings necessarily align current understanding political alignment across states.","code":"pcor_dist <- function(data){   1 - abs(cor(t(data), use = \"pairwise.complete.obs\")) }  dist.repub <- all_votes_repub |>    pcor_dist() |>   as.dist() |>   usedist::dist_setNames(rownames(votes_repub)) |>   hclust(method = \"complete\") |>    as.dendrogram() |>   plot(ylab = \"Pearson correlation distance\")"},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"heatmaps","dir":"Articles","previous_headings":"Presidential Candidate Voting Data","what":"Heatmaps","title":"Resistant correlations and clustering with the biwt package","text":"expand dendrogram, add heatmaps help visualize similarities differences among states. color cell represents observed value given dataset (proportion votes Republican candidate). shown key, blue box , fewer votes Republican candidate received. point Democratic candidate necessarily earn remainder votes Republican candidate earn. example, substantial number votes cast Green Party candidate write-candidates. heatmap examples heavily inspired Cluster Analysis vignette dendextend R package.","code":""},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"biweight-heatmap","dir":"Articles","previous_headings":"Presidential Candidate Voting Data > Heatmaps","what":"Biweight Heatmap","title":"Resistant correlations and clustering with the biwt package","text":"Extending dendrogram, can see biweight correlation good method clustering voting dataset can see distinct separation two groups states. Specifically, observing years 2000 2020, heatmap depicts roughly half states voting primarily Republican candidate half states voting primarily candidates.","code":"par(mar = c(1,1,1,1)) bdend <- all_votes_repub |>    biwt.cor(r = 0.2, absval = FALSE, output = \"distance\") |>   as.dist() |>   usedist::dist_setNames(rownames(all_votes_repub)) |>    hclust(method = \"complete\") |>    as.dendrogram() |>    dendextend::rotate(labels(dend_NA)) |>   dendextend::color_branches(k=4)  gplots::heatmap.2(as.matrix(all_votes_repub),           main = \"Votes for\\n Republican Presidential Candidate\",           srtCol = 60,           dendrogram = \"row\",           Rowv = bdend,           Colv = \"NA\", # this to make sure the columns are not ordered           trace=\"none\",                     key.xlab = \"% Votes for Republican\\n Presidential Candidate\",           labCol = years,           denscol = \"grey\",           density.info = \"none\",           keysize = 1,           key.title = \"\",           col = color_gradient          )"},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"euclidean-heatmap","dir":"Articles","previous_headings":"Presidential Candidate Voting Data > Heatmaps","what":"Euclidean Heatmap","title":"Resistant correlations and clustering with the biwt package","text":"Euclidean distance relies heavily strong voting patterns first half 20th century. voting patterns recent years seem align designated clusters. example, large turquoise group (middle) variety states high percentages votes Republican candidate states low percentages votes Republican candidate 2000 2020.","code":"par(mar = c(1,1,1,1)) edend <- votes_repub |>    dist() |>   hclust(method = \"complete\") |>    as.dendrogram() |>   dendextend::rotate(labels(dend_NA)) |>   dendextend::color_branches(k=4)  gplots::heatmap.2(as.matrix(all_votes_repub),           main = \"Votes for\\n Republican Presidential Candidate\",           srtCol = 60,           dendrogram = \"row\",           Rowv = edend,           Colv = \"NA\", # this to make sure the columns are not ordered           trace=\"none\",                     key.xlab = \"% Votes for Republican\\n Presidential Candidate\",           labCol = years,           denscol = \"grey\",           density.info = \"none\",           keysize = 1,           key.title = \"\",           col = color_gradient          )"},{"path":"https://hardin47.github.io/biwt/articles/biwt.html","id":"pearson-heatmap","dir":"Articles","previous_headings":"Presidential Candidate Voting Data > Heatmaps","what":"Pearson Heatmap","title":"Resistant correlations and clustering with the biwt package","text":"looking recent years (2000 2020), voting data mostly aligns clusters. olive green group, however, includes mixed percentages, states voted Republican candidate others . earlier years data seem strongly aligned clustering results dendrogram.","code":"par(mar = c(1,1,1,1)) pdend <- all_votes_repub |>    pcor_dist() |>   as.dist() |>   usedist::dist_setNames(rownames(all_votes_repub)) |>   hclust(method = \"complete\") |>    as.dendrogram() |>   dendextend::rotate(labels(dend_NA)) |>   dendextend::color_branches(k=4)  gplots::heatmap.2(as.matrix(all_votes_repub),           main = \"Votes for\\n Republican Presidential Candidate\",           srtCol = 60,           dendrogram = \"row\",           Rowv = pdend,           Colv = \"NA\", # this to make sure the columns are not ordered           trace=\"none\",                     key.xlab = \"% Votes for Republican\\n Presidential Candidate\",           labCol = years,           denscol = \"grey\",           density.info = \"none\",           keysize = 1,           key.title = \"\",           col = color_gradient          )"},{"path":"https://hardin47.github.io/biwt/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Johanna Hardin. Author, maintainer.","code":""},{"path":"https://hardin47.github.io/biwt/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hardin J (2024). biwt: Functions compute biweight mean vector covariance correlation matrices. R package version 1.1.0, https://hardin47.github.io/biwt/, https://github.com/hardin47/biwt.","code":"@Manual{,   title = {biwt: Functions to compute the biweight mean vector and covariance and correlation matrices},   author = {Johanna Hardin},   year = {2024},   note = {R package version 1.1.0, https://hardin47.github.io/biwt/},   url = {https://github.com/hardin47/biwt}, }"},{"path":[]},{"path":"https://hardin47.github.io/biwt/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Functions to compute the biweight mean vector and covariance and correlation matrices","text":"biwt package includes base function compute multivariate location, scale, correlation estimates based Tukey’s biweight M-estimator. Using base function, computations can applied large number observations create either matrix biweight distances biweight correlations. primary functions biwt package : biwt.est biwt_est biwt.cor biwt_cor biwt_cor_matrix biwt_dist_matrix","code":""},{"path":"https://hardin47.github.io/biwt/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Functions to compute the biweight mean vector and covariance and correlation matrices","text":"Running following lines code R install package Github:","code":"library(devtools) devtools::install_github(repo = \"hardin47/biwt\")"},{"path":"https://hardin47.github.io/biwt/index.html","id":"instructions","dir":"","previous_headings":"","what":"Instructions","title":"Functions to compute the biweight mean vector and covariance and correlation matrices","text":"See documentation.pdf information use package. portion example given documentation reproduced convenience.","code":"set.seed(4747) samp.data <- MASS::mvrnorm(30, mu=c(0,0,0),                            Sigma=matrix(c(1,.75,-.75,.75,1,-.75,-.75,-.75,1),                           ncol=3))  r<-0.2 # breakdown  biwt.cor(samp.data[,1:2], r=.2)$biwt.cor biwt.cor(samp.data[,c(1,3)], r=.2)$biwt.cor biwt.cor(samp.data[,c(2,3)], r=.2)$biwt.cor   biwt.cor(samp.data, r=.2)  biwt.cor.matrix(samp.data, r=.2)  biwt.dist.matrix(samp.data, r=.2, absval=TRUE) biwt.dist.matrix(samp.data, r=.2, absval=FALSE)"},{"path":"https://hardin47.github.io/biwt/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Functions to compute the biweight mean vector and covariance and correlation matrices","text":"See DESCRIPTION information.","code":""},{"path":"https://hardin47.github.io/biwt/index.html","id":"author","dir":"","previous_headings":"","what":"Author","title":"Functions to compute the biweight mean vector and covariance and correlation matrices","text":"Johanna Hardin","code":""},{"path":"https://hardin47.github.io/biwt/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Functions to compute the biweight mean vector and covariance and correlation matrices","text":"Hardin, J., Mitani, ., Hicks, L., VanKoten, B.; Robust Measure Correlation Two Genes Microarray, BMC Bioinformatics, 8:220; 2007. https://doi.org/10.1186/1471-2105-8-220","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt.cor.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to compute the biweight mean vector and covariance matrix — biwt.cor","title":"A function to compute the biweight mean vector and covariance matrix — biwt.cor","text":"function compute biweight mean vector covariance matrix","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt.cor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to compute the biweight mean vector and covariance matrix — biwt.cor","text":"","code":"biwt.cor(   x,   r = 0.2,   output = \"matrix\",   median = TRUE,   full.init = TRUE,   absval = TRUE )"},{"path":"https://hardin47.github.io/biwt/reference/biwt.cor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to compute the biweight mean vector and covariance matrix — biwt.cor","text":"x g x n matrix data frame (n number measurements, g number observations (genes) ) r breakdown (k/n k largest number observations can replaced arbitrarily large values keeping estimates bounded). Default r = 0.2. output character string specifying output format.  Options \"matrix\" (default), \"vector\", \"distance\".  See value . median logical command determine whether initialization done using coordinate-wise median MAD^2 (TRUE, default) using minimum covariance determinant (MCD) (FALSE).  Using MCD substantially slower. MAD median absolute deviations median.  See R help file mad. full.init logical command determine whether initialization done pair separately (FALSE) one time beginning using entire data matrix (TRUE, default).  Initializing pair separately substantially slower. absval logical command determine whether distance measured 1 minus absolute value correlation (TRUE, default) 1 minus correlation (FALSE).","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt.cor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to compute the biweight mean vector and covariance matrix — biwt.cor","text":"Specifying \"vector\" output argument returns vector consisting lower triangle correlation matrix stored columns vector, say \\(bwcor\\). \\(g\\) number observations \\(bwcor\\) correlation vector, \\(< j <= g\\), biweight correlation (rows) \\(\\) \\(j\\) \\(bwcor[(j-1)*(j-2)/2 + ]\\). length vector \\(g*(g-1)/2\\), .e., order \\(g^2\\). Specifying \"matrix\" output argument returns matrix biweight correlations. Specifying \"distance\" output argument returns matrix biweight distances (default 1 minus absolute value biweight correlation). much missing data initialization accurate, function compute MCD given pair observations computing biweight correlation (regardless initial settings given call function). \"vector\" output option given correlations can stored vectors less computationally intensive matrices. Returns list components: corr vector consisting lower triangle correlation matrix stored columns vector, say bwcor. g number observations, .e., \\(< j \\leq g\\), biweight correlation (rows) j bwcor[\\(g*(-1) - *(-1)/2 + j-\\)]. dimension matrix \\(g x g\\). corr.mat matrix consisting lower triangle correlation matrix stored columns vector, say bwcor. g number observations, .e., \\(< j \\leq g\\), biweight correlation (rows) j bwcor[\\(g*(-1) - *(-1)/2 + j-\\)]. length vector \\(g*(g-1)/2\\), .e., order \\(g^2\\). dist.mat matrix consisting correlations converted distances (either 1 - correlation 1 - abs(correlation)).","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt.cor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A function to compute the biweight mean vector and covariance matrix — biwt.cor","text":"","code":"# note that biwt.cor() takes data that is gxn where the # goal is to find correlations or distances between each of the g items  samp.data <- t(MASS::mvrnorm(30,mu=c(0,0,0),                Sigma=matrix(c(1,.75,-.75,.75,1,-.75,-.75,-.75,1),ncol=3)))  # To compute the 3 pairwise correlations from the sample data:  samp.bw.cor <- biwt.cor(samp.data, output=\"vector\") samp.bw.cor #> [1]  0.7838299 -0.8014326 -0.7921604  # To compute the 3 pairwise correlations in matrix form:  samp.bw.cor.mat <- biwt.cor(samp.data) samp.bw.cor.mat #>            [,1]       [,2]       [,3] #> [1,]  1.0000000  0.7838299 -0.8014326 #> [2,]  0.7838299  1.0000000 -0.7921606 #> [3,] -0.8014326 -0.7921606  1.0000000  # To compute the 3 pairwise distances in matrix form:  samp.bw.dist.mat <- biwt.cor(samp.data, output=\"distance\") samp.bw.dist.mat #>           [,1]      [,2]      [,3] #> [1,] 0.0000000 0.2161701 0.1985674 #> [2,] 0.2161701 0.0000000 0.2078394 #> [3,] 0.1985674 0.2078394 0.0000000  # To convert the distances into an object of class `dist'  as.dist(samp.bw.dist.mat) #>           1         2 #> 2 0.2161701           #> 3 0.1985674 0.2078394"},{"path":"https://hardin47.github.io/biwt/reference/biwt.est.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to compute the biweight mean vector and covariance matrix — biwt.est","title":"A function to compute the biweight mean vector and covariance matrix — biwt.est","text":"Compute multivariate location scale estimate based Tukey's biweight weight function.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt.est.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to compute the biweight mean vector and covariance matrix — biwt.est","text":"","code":"biwt.est(x, r = 0.2, med.init = robustbase::covMcd(x))"},{"path":"https://hardin47.github.io/biwt/reference/biwt.est.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to compute the biweight mean vector and covariance matrix — biwt.est","text":"x 2 x n matrix data frame (n number measurements) r breakdown (k/n k largest number measurements can replaced arbitrarily large values keeping estimates bounded). Default r = 0.2. med.init (robust) initial estimate center shape data.  format list components center cov (output covMcd() rrcov package). Default minimum covariance determinant (MCD) data.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt.est.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to compute the biweight mean vector and covariance matrix — biwt.est","text":"list components biwt.mu final estimate center biwt.sig final estimate shape","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt.est.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"A function to compute the biweight mean vector and covariance matrix — biwt.est","text":"Hardin, J., Mitani, ., Hicks, L., VanKoten, B.; Robust Measure Correlation Two Genes Microarray, BMC Bioinformatics, 8:220; 2007.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt.est.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A function to compute the biweight mean vector and covariance matrix — biwt.est","text":"","code":"# note that biwt.est() takes data that is 2xn where the # goal is to find the correlation between the 2 items  samp.data <- t(MASS::mvrnorm(30,mu=c(0,0),                Sigma=matrix(c(1,.75,.75,1),ncol=2)))  samp.bw <- biwt.est(samp.data) samp.bw #> $biwt.mu #> [1] 0.2923344 0.2346656 #>  #> $biwt.sig #>           [,1]      [,2] #> [1,] 0.6248218 0.5618640 #> [2,] 0.5618640 0.8092572 #>   samp.bw.var1 <- samp.bw$biwt.sig[1,1] samp.bw.var2 <- samp.bw$biwt.sig[2,2] samp.bw.cov <- samp.bw$biwt.sig[1,2]  samp.bw.cor <- samp.bw.cov / sqrt(samp.bw.var1 * samp.bw.var2) samp.bw.cor #> [1] 0.7901505  # or:  samp.bw.cor <- samp.bw$biwt.sig[1,2] / sqrt(samp.bw$biwt.sig[1,1]*samp.bw$biwt.sig[2,2]) samp.bw.cor #> [1] 0.7901505  ############## # to speed up the calculations, use the median/mad for the initialization: ##############  samp.init <- list() samp.init$cov <- diag(apply(samp.data, 1, stats::mad, na.rm=TRUE)) samp.init$center <- apply(samp.data, 1, median, na.rm=TRUE) samp.init #> $cov #>          [,1]     [,2] #> [1,] 1.033435 0.000000 #> [2,] 0.000000 1.395451 #>  #> $center #> [1] 0.38901627 0.08568794 #>   samp.bw <- biwt.est(samp.data, med.init = samp.init) samp.bw.cor <- samp.bw$biwt.sig[1,2] / sqrt(samp.bw$biwt.sig[1,1]*samp.bw$biwt.sig[2,2]) samp.bw.cor #> [1] 0.7901505"},{"path":"https://hardin47.github.io/biwt/reference/biwt_cor.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to compute the biweight mean vector and covariance matrix — biwt_cor","title":"A function to compute the biweight mean vector and covariance matrix — biwt_cor","text":"function compute biweight mean vector covariance matrix","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_cor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to compute the biweight mean vector and covariance matrix — biwt_cor","text":"","code":"biwt_cor(x, r, median = TRUE, full_init = TRUE)"},{"path":"https://hardin47.github.io/biwt/reference/biwt_cor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to compute the biweight mean vector and covariance matrix — biwt_cor","text":"x n x g matrix data frame (n number measurements, g number observations (genes) ) r breakdown (k/n k largest number observations can replaced arbitrarily large values keeping estimates bounded) median logical command determine whether initialization done using coordinate-wise median MAD (TRUE) using minimum covariance determinant (MCD)  (FALSE).  Using MCD substantially slower. full_init logical command determine whether initialization done pair separately (FALSE) one time beginning using entire data matrix (TRUE).  Initializing pair separately substantially slower.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_cor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to compute the biweight mean vector and covariance matrix — biwt_cor","text":"Using biwt_est estimate robust covariance matrix, robust measure correlation computed using Tukey's biweight M-estimator. biweight correlation essentially weighted correlation weights calculated based distance measurement data center respect shape data.  correlations computed pair--pair weights depend pairwise relationship hand relationship observations globally.  biwt functions compute many pairwise correlations create distance matrices use algorithms (e.g., clustering). order biweight estimates converge, reasonable initialization must given. Typically, using TRUE median full_init arguments provide acceptable initializations. particularly irregular data, MCD used give initial estimate center shape. data sets observations orders magnitudes different, full_init=FALSE specified. Returns list components: biwt_corr vector consisting lower triangle correlation matrix stored columns vector, say bwcor. g number observations, .e., \\(< j \\leq g\\), biweight correlation (rows) j bwcor[\\(g*(-1) - *(-1)/2 + j-\\)]. length vector \\(g*(g-1)/2\\), .e., order \\(g^2\\). biwt_NAid vector indexed way biwt_corr.  entries represent whether biweight correlation possible compute (NA much data missing initializations accurate).  0 computed accurately, 1 NA.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_cor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A function to compute the biweight mean vector and covariance matrix — biwt_cor","text":"","code":"# note that biwt_cor() takes data that is nxg where the # goal is to find correlations between each of the g items  samp_data <- MASS::mvrnorm(30,mu=c(0,0,0),Sigma=matrix(c(1,.75,-.75,.75,1,-.75,-.75,-.75,1),ncol=3)) r <- 0.2 # breakdown  # To compute the 3 pairwise correlations from the sample data:  samp_bw_cor <- biwt_cor(samp_data,r) samp_bw_cor #> $biwt_corr #> [1]  0.6884415 -0.6393075 -0.6570438 #>  #> $biwt_NAid #> NULL #>"},{"path":"https://hardin47.github.io/biwt/reference/biwt_cor_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to compute the biweight mean vector and covariance matrix — biwt_cor_matrix","title":"A function to compute the biweight mean vector and covariance matrix — biwt_cor_matrix","text":"Compute multivariate location scale estimate based Tukey's biweight weight function.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_cor_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to compute the biweight mean vector and covariance matrix — biwt_cor_matrix","text":"","code":"biwt_cor_matrix(x, r, median = TRUE, full_init = TRUE)"},{"path":"https://hardin47.github.io/biwt/reference/biwt_cor_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to compute the biweight mean vector and covariance matrix — biwt_cor_matrix","text":"x n x g matrix data frame (n number measurements, g number observations (genes) ) r breakdown (k/n k largest number observations can replaced arbitrarily large values keeping estimates bounded) median logical command determine whether initialization done using coordinate-wise median MAD (TRUE) using minimum covariance determinant (MCD)  (FALSE).  Using MCD substantially slower. full_init logical command determine whether initialization done pair separately (FALSE) one time beginning using entire data matrix (TRUE).  Initializing pair separately substantially slower.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_cor_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to compute the biweight mean vector and covariance matrix — biwt_cor_matrix","text":"Using biwt_est estimate robust covariance matrix, robust measure correlation computed using Tukey's biweight M-estimator. biweight correlation essentially weighted correlation weights calculated based distance measurement data center respect shape data.  correlations computed pair--pair weights depend pairwise relationship hand relationship observations globally.  biwt functions compute many pairwise correlations create distance matrices use algorithms (e.g., clustering). order biweight estimates converge, reasonable initialization must given. Typically, using TRUE median full_init arguments provide acceptable initializations. particularly irregular data, MCD used give initial estimate center shape. data sets observations orders magnitudes different, full_init=FALSE specified. Returns list components: biwt_corr_matrix matrix biweight correlations. biwt_NAid_matrix matrix representing whether biweight correlation possible compute (NA much data missing initializations accurate).  0 computed accurately, 1 NA.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_cor_matrix.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"A function to compute the biweight mean vector and covariance matrix — biwt_cor_matrix","text":"Hardin, J., Mitani, ., Hicks, L., VanKoten, B.; Robust Measure Correlation Two Genes Microarray, BMC Bioinformatics, 8:220; 2007.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_cor_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A function to compute the biweight mean vector and covariance matrix — biwt_cor_matrix","text":"","code":"# note that biwt_cor_matrix() takes data that is nxg where the # goal is to find correlations between each of the g items  samp_data <- MASS::mvrnorm(30,mu=c(0,0,0),Sigma=matrix(c(1,.75,-.75,.75,1,-.75,-.75,-.75,1),ncol=3)) r <- 0.2 # breakdown  # To compute the 3 pairwise correlations in matrix form:  samp_bw_cor_mat <- biwt_cor_matrix(samp_data,r) samp_bw_cor_mat #> $biwt_corr_mat #>            [,1]       [,2]       [,3] #> [1,]  1.0000000  0.7683841 -0.7918474 #> [2,]  0.7683841  1.0000000 -0.7820574 #> [3,] -0.7918474 -0.7820574  1.0000000 #>  #> $biwt_NAid_mat #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #> [3,]    0    0    0 #>"},{"path":"https://hardin47.github.io/biwt/reference/biwt_dist_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to compute the biweight mean vector and covariance matrix — biwt_dist_matrix","title":"A function to compute the biweight mean vector and covariance matrix — biwt_dist_matrix","text":"Compute multivariate location scale estimate based Tukey's biweight weight function.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_dist_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to compute the biweight mean vector and covariance matrix — biwt_dist_matrix","text":"","code":"biwt_dist_matrix(x, r, median = TRUE, full_init = TRUE, absval = TRUE)"},{"path":"https://hardin47.github.io/biwt/reference/biwt_dist_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to compute the biweight mean vector and covariance matrix — biwt_dist_matrix","text":"x n x g matrix data frame (n number measurements, g number observations (genes) ) r breakdown (k/n k largest number observations can replaced arbitrarily large values keeping estimates bounded) median logical command determine whether initialization done using coordinate-wise median MAD (TRUE) using minimum covariance determinant (MCD)  (FALSE).  Using MCD substantially slower. full_init logical command determine whether initialization done pair separately (FALSE) one time beginning using entire data matrix (TRUE).  Initializing pair separately substantially slower. absval logical command determine whether distance measured 1 minus absolute value correlation (TRUE) simply 1 minus correlation (FALSE)","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_dist_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to compute the biweight mean vector and covariance matrix — biwt_dist_matrix","text":"Using biwt_est estimate robust covariance matrix, robust measure correlation computed using Tukey's biweight M-estimator. biweight correlation essentially weighted correlation weights calculated based distance measurement data center respect shape data.  correlations computed pair--pair weights depend pairwise relationship hand relationship observations globally.  biwt functions compute many pairwise correlations create distance matrices use algorithms (e.g., clustering). order biweight estimates converge, reasonable initialization must given. Typically, using TRUE median full_init arguments provide acceptable initializations. particularly irregular data, MCD used give initial estimate center shape. data sets observations orders magnitudes different, full_init=FALSE specified. Returns list components: biwt_dist_matrix matrix biweight distances (default 1 minus absolute value biweight correlation). biwt_NAid_matrix matrix representing whether biweight correlation possible compute (NA much data missing initializations accurate).  0 computed accurately, 1 NA.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_dist_matrix.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"A function to compute the biweight mean vector and covariance matrix — biwt_dist_matrix","text":"Hardin, J., Mitani, ., Hicks, L., VanKoten, B.; Robust Measure Correlation Two Genes Microarray, BMC Bioinformatics, 8:220; 2007.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_dist_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A function to compute the biweight mean vector and covariance matrix — biwt_dist_matrix","text":"","code":"# note that biwt_dist_matrix() takes data that is nxg where the # goal is to find distances between each of the g items  samp_data <- MASS::mvrnorm(30,mu=c(0,0,0),Sigma=matrix(c(1,.75,-.75,.75,1,-.75,-.75,-.75,1),ncol=3)) r <- 0.2 # breakdown  # To compute the 3 pairwise distances in matrix form: samp_bw_dist_mat <- biwt_dist_matrix(samp_data, r) samp_bw_dist_mat #> $biwt_dist_mat #>           [,1]      [,2]      [,3] #> [1,] 0.0000000 0.2503933 0.3097497 #> [2,] 0.2503933 0.0000000 0.3428037 #> [3,] 0.3097497 0.3428037 0.0000000 #>  #> $biwt_NAid_mat #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #> [3,]    0    0    0 #>   # To convert the distances into an element of class 'dist' as.dist(samp_bw_dist_mat$biwt_dist_mat) #>           1         2 #> 2 0.2503933           #> 3 0.3097497 0.3428037"},{"path":"https://hardin47.github.io/biwt/reference/biwt_est.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to compute the biweight mean vector and covariance matrix — biwt_est","title":"A function to compute the biweight mean vector and covariance matrix — biwt_est","text":"Compute multivariate location scale estimate based Tukey's biweight weight function.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_est.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to compute the biweight mean vector and covariance matrix — biwt_est","text":"","code":"biwt_est(x, r, med.init)"},{"path":"https://hardin47.github.io/biwt/reference/biwt_est.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to compute the biweight mean vector and covariance matrix — biwt_est","text":"x n x 2 matrix data frame (n number observations) r breakdown (k/n k largest number observations can replaced arbitrarily large values keeping estimates bounded) med.init (robust) initial estimate center shape data.  form list components center cov.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_est.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to compute the biweight mean vector and covariance matrix — biwt_est","text":"robust measure center shape computed using Tukey's biweight M-estimator.  biweight estimates essentially weighted means covariances weights calculated based distance measurement data center respect shape data.  estimates computed pair--pair weights depend pairwise relationship hand relationship observations globally. Returns list components: biwt_mu final estimate location biwt_sig final estimate scatter biwt_NAid logical whether given initialization used (coded 0) whether precise initialization used (namely, pair pair MCD, coded 1).","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_est.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"A function to compute the biweight mean vector and covariance matrix — biwt_est","text":"Hardin, J., Mitani, ., Hicks, L., VanKoten, B.; Robust Measure Correlation Two Genes Microarray, BMC Bioinformatics, 8:220; 2007.","code":""},{"path":"https://hardin47.github.io/biwt/reference/biwt_est.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A function to compute the biweight mean vector and covariance matrix — biwt_est","text":"","code":"# note that biwt_est() takes data that is nx2 where the # goal is to find the correlation between the 2 items  samp_data <- MASS::mvrnorm(30,mu=c(0,0),Sigma=matrix(c(1,.75,.75,1),ncol=2)) r <- 0.2 # breakdown  samp_mcd <- robustbase::covMcd(samp_data) samp_bw <- biwt_est(samp_data, r, samp_mcd)  samp_bw_var1 <- samp_bw$biwt_sig[1,1] samp_bw_var2 <- samp_bw$biwt_sig[2,2] samp_bw_cov <- samp_bw$biwt_sig[1,2]  samp_bw_corr <- samp_bw_cov / sqrt(samp_bw_var1 * samp_bw_var2)  # or:  samp_bw_corr <- samp_bw$biwt_sig[1,2] / sqrt(samp_bw$biwt_sig[1,1]*samp_bw$biwt_sig[2,2]) samp_bw_corr #> [1] 0.7951656  ############## # to speed up the calculations, use the median/mad for the initialization: ##############  samp_init <- list() samp_init$cov <- diag(apply(samp_data, 2, stats::mad, na.rm=TRUE)) samp_init$center <- apply(samp_data, 2, median, na.rm=TRUE)  samp_bw <- biwt_est(samp_data, r, samp_init) samp_bw_corr <- samp_bw$biwt.sig[1,2] / sqrt(samp_bw$biwt.sig[1,1]*samp_bw$biwt.sig[2,2])"},{"path":"https://hardin47.github.io/biwt/reference/chi.int.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function — chi.int","title":"Internal function — chi.int","text":"Internal function","code":""},{"path":"https://hardin47.github.io/biwt/reference/chi.int.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function — chi.int","text":"","code":"chi.int(p, a, c1)"},{"path":"https://hardin47.github.io/biwt/reference/chi.int.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function — chi.int","text":"p number number c1 number","code":""},{"path":"https://hardin47.github.io/biwt/reference/chi.int.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function — chi.int","text":"number","code":""},{"path":"https://hardin47.github.io/biwt/reference/chi.int.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function — chi.int","text":"","code":"chi.int(2,3,4) #> [1] 3.734209"},{"path":"https://hardin47.github.io/biwt/reference/chi.int.p.html","id":null,"dir":"Reference","previous_headings":"","what":"Title — chi.int.p","title":"Title — chi.int.p","text":"Title","code":""},{"path":"https://hardin47.github.io/biwt/reference/chi.int.p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title — chi.int.p","text":"","code":"chi.int.p(p, a, c1)"},{"path":"https://hardin47.github.io/biwt/reference/chi.int.p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title — chi.int.p","text":"p number number c1 number","code":""},{"path":"https://hardin47.github.io/biwt/reference/chi.int.p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title — chi.int.p","text":"number","code":""},{"path":"https://hardin47.github.io/biwt/reference/chi.int.p.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Title — chi.int.p","text":"","code":"chi.int.p(1,2,3) #> [1] 0.07977327"},{"path":"https://hardin47.github.io/biwt/reference/chi.int2.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function — chi.int2","title":"Internal function — chi.int2","text":"Internal function","code":""},{"path":"https://hardin47.github.io/biwt/reference/chi.int2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function — chi.int2","text":"","code":"chi.int2(p, a, c1)"},{"path":"https://hardin47.github.io/biwt/reference/chi.int2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function — chi.int2","text":"p number number c1 number","code":""},{"path":"https://hardin47.github.io/biwt/reference/chi.int2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function — chi.int2","text":"number","code":""},{"path":"https://hardin47.github.io/biwt/reference/chi.int2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function — chi.int2","text":"","code":"chi.int(2,3,4) #> [1] 3.734209"},{"path":"https://hardin47.github.io/biwt/reference/chi.int2.p.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function — chi.int2.p","title":"Internal function — chi.int2.p","text":"Internal function","code":""},{"path":"https://hardin47.github.io/biwt/reference/chi.int2.p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function — chi.int2.p","text":"","code":"chi.int2.p(p, a, c1)"},{"path":"https://hardin47.github.io/biwt/reference/chi.int2.p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function — chi.int2.p","text":"p number number c1 number","code":""},{"path":"https://hardin47.github.io/biwt/reference/chi.int2.p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function — chi.int2.p","text":"number","code":""},{"path":"https://hardin47.github.io/biwt/reference/chi.int2.p.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function — chi.int2.p","text":"","code":"chi.int2.p(2,3,4) #> [1] -0.08587843"},{"path":"https://hardin47.github.io/biwt/reference/erho.bw.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function — erho.bw","title":"Internal function — erho.bw","text":"Internal function","code":""},{"path":"https://hardin47.github.io/biwt/reference/erho.bw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function — erho.bw","text":"","code":"erho.bw(p, c1)"},{"path":"https://hardin47.github.io/biwt/reference/erho.bw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function — erho.bw","text":"p number c1 cutoff","code":""},{"path":"https://hardin47.github.io/biwt/reference/erho.bw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function — erho.bw","text":"number, expected value rho","code":""},{"path":"https://hardin47.github.io/biwt/reference/erho.bw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function — erho.bw","text":"","code":"erho.bw(2,3) #> [1] 0.6532238"},{"path":"https://hardin47.github.io/biwt/reference/erho.bw.p.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function — erho.bw.p","title":"Internal function — erho.bw.p","text":"Internal function","code":""},{"path":"https://hardin47.github.io/biwt/reference/erho.bw.p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function — erho.bw.p","text":"","code":"erho.bw.p(p, c1)"},{"path":"https://hardin47.github.io/biwt/reference/erho.bw.p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function — erho.bw.p","text":"p number c1 cutoff","code":""},{"path":"https://hardin47.github.io/biwt/reference/erho.bw.p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function — erho.bw.p","text":"number, derivative expected value rho","code":""},{"path":"https://hardin47.github.io/biwt/reference/erho.bw.p.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function — erho.bw.p","text":"","code":"erho.bw.p(2,3) #> [1] 0.1693635"},{"path":"https://hardin47.github.io/biwt/reference/ksolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function — ksolve","title":"Internal function — ksolve","text":"Internal function","code":""},{"path":"https://hardin47.github.io/biwt/reference/ksolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function — ksolve","text":"","code":"ksolve(d, p, c1, b0)"},{"path":"https://hardin47.github.io/biwt/reference/ksolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function — ksolve","text":"d vector p number c1 number b0 number","code":""},{"path":"https://hardin47.github.io/biwt/reference/ksolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function — ksolve","text":"number","code":""},{"path":"https://hardin47.github.io/biwt/reference/ksolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function — ksolve","text":"","code":"ksolve(rnorm(20,.1,2),1,3,1) #> [1] 0.3713295"},{"path":"https://hardin47.github.io/biwt/reference/psibw.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function — psibw","title":"Internal function — psibw","text":"Internal function","code":""},{"path":"https://hardin47.github.io/biwt/reference/psibw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function — psibw","text":"","code":"psibw(x, c1)"},{"path":"https://hardin47.github.io/biwt/reference/psibw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function — psibw","text":"x vector c1 cutoff","code":""},{"path":"https://hardin47.github.io/biwt/reference/psibw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function — psibw","text":"vector","code":""},{"path":"https://hardin47.github.io/biwt/reference/psibw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function — psibw","text":"","code":"psibw(rnorm(10),3) #>  [1]  0.4716421  0.2101300 -0.4485440  0.7406652  0.5910147 -0.5571721 #>  [7]  0.7805375 -0.4774297  0.8585444 -0.3177337"},{"path":"https://hardin47.github.io/biwt/reference/rejpt.bw.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function — rejpt.bw","title":"Internal function — rejpt.bw","text":"Internal function","code":""},{"path":"https://hardin47.github.io/biwt/reference/rejpt.bw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function — rejpt.bw","text":"","code":"rejpt.bw(p, r)"},{"path":"https://hardin47.github.io/biwt/reference/rejpt.bw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function — rejpt.bw","text":"p number r breakdown","code":""},{"path":"https://hardin47.github.io/biwt/reference/rejpt.bw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function — rejpt.bw","text":"asymptotic rejection point","code":""},{"path":"https://hardin47.github.io/biwt/reference/rejpt.bw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function — rejpt.bw","text":"","code":"rejpt.bw(2,3) #> [1]  2.510501e-03  3.151302e-06 -1.368595e-06"},{"path":"https://hardin47.github.io/biwt/reference/rhobw.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function — rhobw","title":"Internal function — rhobw","text":"Internal function","code":""},{"path":"https://hardin47.github.io/biwt/reference/rhobw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function — rhobw","text":"","code":"rhobw(x, c1)"},{"path":"https://hardin47.github.io/biwt/reference/rhobw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function — rhobw","text":"x number c1 cutoff","code":""},{"path":"https://hardin47.github.io/biwt/reference/rhobw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function — rhobw","text":"number","code":""},{"path":"https://hardin47.github.io/biwt/reference/rhobw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function — rhobw","text":"","code":"rhobw(2,3) #> [1] 1.242798"},{"path":"https://hardin47.github.io/biwt/reference/vbw.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function — vbw","title":"Internal function — vbw","text":"Internal function","code":""},{"path":"https://hardin47.github.io/biwt/reference/vbw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function — vbw","text":"","code":"vbw(x, c1)"},{"path":"https://hardin47.github.io/biwt/reference/vbw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function — vbw","text":"x vector c1 cutoff","code":""},{"path":"https://hardin47.github.io/biwt/reference/vbw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function — vbw","text":"vector","code":""},{"path":"https://hardin47.github.io/biwt/reference/vbw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function — vbw","text":"","code":"vbw(rnorm(10),3) #>  [1] 1.16071599 0.66912219 0.44372504 0.49979738 1.32375296 0.00000000 #>  [7] 0.38481797 0.10153869 0.62840199 0.06455678"},{"path":"https://hardin47.github.io/biwt/reference/vect2diss.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function — vect2diss","title":"Internal function — vect2diss","text":"Internal function","code":""},{"path":"https://hardin47.github.io/biwt/reference/vect2diss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function — vect2diss","text":"","code":"vect2diss(v)"},{"path":"https://hardin47.github.io/biwt/reference/vect2diss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function — vect2diss","text":"v vector","code":""},{"path":"https://hardin47.github.io/biwt/reference/vect2diss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function — vect2diss","text":"vector","code":""},{"path":"https://hardin47.github.io/biwt/reference/vect2diss.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function — vect2diss","text":"","code":"vect2diss(rnorm(10)) #>            [,1]       [,2]       [,3]       [,4]       [,5] #> [1,]  0.0000000 -1.6630567 -0.7206361 -1.5182012  0.2598215 #> [2,] -1.6630567  0.0000000  0.2500805  0.4470079  1.0179657 #> [3,] -0.7206361  0.2500805  0.0000000  0.9003209  0.6142713 #> [4,] -1.5182012  0.4470079  0.9003209  0.0000000 -0.2394080 #> [5,]  0.2598215  1.0179657  0.6142713 -0.2394080  0.0000000"},{"path":"https://hardin47.github.io/biwt/reference/vect2diss_hop.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function — vect2diss_hop","title":"Internal function — vect2diss_hop","text":"Internal function","code":""},{"path":"https://hardin47.github.io/biwt/reference/vect2diss_hop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function — vect2diss_hop","text":"","code":"vect2diss_hop(v)"},{"path":"https://hardin47.github.io/biwt/reference/vect2diss_hop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function — vect2diss_hop","text":"v vector","code":""},{"path":"https://hardin47.github.io/biwt/reference/vect2diss_hop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function — vect2diss_hop","text":"vector","code":""},{"path":"https://hardin47.github.io/biwt/reference/vect2diss_hop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function — vect2diss_hop","text":"","code":"vect2diss_hop(rnorm(10)) #>             [,1]       [,2]        [,3]        [,4]       [,5] #> [1,]  0.00000000 -1.8031493  0.01342568 -0.06732869  1.6787554 #> [2,] -1.80314928  0.0000000 -0.25145721 -0.85524888  0.0293183 #> [3,]  0.01342568 -0.2514572  0.00000000 -0.35208949 -1.3680452 #> [4,] -0.06732869 -0.8552489 -0.35208949  0.00000000  0.4846134 #> [5,]  1.67875542  0.0293183 -1.36804516  0.48461339  0.0000000"},{"path":"https://hardin47.github.io/biwt/reference/wtbw.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function — wtbw","title":"Internal function — wtbw","text":"Internal function","code":""},{"path":"https://hardin47.github.io/biwt/reference/wtbw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function — wtbw","text":"","code":"wtbw(x, c1)"},{"path":"https://hardin47.github.io/biwt/reference/wtbw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function — wtbw","text":"x vector c1 number","code":""},{"path":"https://hardin47.github.io/biwt/reference/wtbw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function — wtbw","text":"vector","code":""},{"path":"https://hardin47.github.io/biwt/reference/wtbw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function — wtbw","text":"","code":"wtbw(rnorm(10),3) #>  [1] 0.8939644 0.9939680 0.9539260 0.9698907 0.8579577 0.9589044 0.7257930 #>  [8] 0.5548566 0.9894773 0.9744093"}]
